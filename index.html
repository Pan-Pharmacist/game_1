<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pan Journey</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #d6eaf8;
            font-family: 'Prompt', sans-serif;
        }
        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 16px;
            pointer-events: none;
            user-select: none;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 1px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .level-indicator {
            font-size: 1.2rem;
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
        }
        p {
            margin: 5px 0;
            font-size: 0.9rem;
            opacity: 0.95;
        }
        .key {
            display: inline-block;
            background: rgba(255,255,255,0.3);
            padding: 2px 8px;
            border-radius: 6px;
            font-family: monospace;
            font-weight: bold;
            color: #fff;
        }
        #message-overlay {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #message-text {
            font-size: 3rem;
            font-weight: 800;
            color: white;
            text-shadow: 0 4px 10px rgba(0,0,0,0.2);
            background: rgba(0,0,0,0.1);
            padding: 20px 40px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Prompt:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="ui-layer">
        <h1>Pan Journey</h1>
        <span id="level-display" class="level-indicator">Stage: 1/10</span>
        <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> เดิน</p>
        <p><span class="key">Space</span> กระโดด</p>
        <p><span class="key">Shift</span> วิ่ง</p>
        <p><span class="key">Mouse Drag</span> หมุนมุมกล้อง</p>
    </div>

    <div id="message-overlay">
        <div id="message-text">CHECKPOINT!</div>
    </div>

    <div id="canvas-container"></div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Constants & Config ---
        const GRAVITY = 0.015;
        const JUMP_FORCE = 0.35;
        const SPEED = 0.15;
        const RUN_SPEED = 0.25;
        const ROTATION_SPEED = 0.1;
        const CAM_DISTANCE = 8;
        const CAM_HEIGHT = 4;
        
        const COLORS = {
            sky: 0xd6eaf8,
            player: 0xff99c8, // Cute Pink
            playerFace: 0x333333,
            checkpoint: 0xa0c4ff, // Pastel Blue
            finish: 0xffd6a5, // Pastel Orange
            platformBase: 0xffffff, // White
            platformTop: 0xbdb2ff, // Purple tint
            water: 0x76d7ea
        };

        // --- Globals ---
        let scene, camera, renderer;
        let playerMesh;
        let platforms = [];
        let checkPoints = [];
        let movingPlatforms = [];
        
        let keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
        let cameraAngle = { x: 0, y: Math.PI }; // y is yaw (horizontal), x is pitch (vertical)
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };

        // Physics State
        let playerState = {
            x: 0, y: 5, z: 0,
            vy: 0,
            onGround: false,
            currentLevel: 1,
            spawnPoint: { x: 0, y: 5, z: 0 }
        };

        // Animation State
        let walkCycle = 0;

        init();
        animate();

        function init() {
            const container = document.getElementById('canvas-container');

            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.sky);
            scene.fog = new THREE.Fog(COLORS.sky, 20, 80);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 4. Light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xfff0dd, 0.8);
            dirLight.position.set(20, 50, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            scene.add(dirLight);

            // 5. Create World
            createPlayer();
            generateLevels();
            createWater();

            // 6. Events
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', e => onKey(e, true));
            document.addEventListener('keyup', e => onKey(e, false));
            
            // Mouse Events (Click to focus is implied by browsers, but explicit focus helps)
            container.addEventListener('mousedown', () => {
                container.focus();
            });

            document.addEventListener('mousedown', e => { isDragging = true; prevMouse = {x: e.clientX, y: e.clientY}; });
            document.addEventListener('mouseup', () => isDragging = false);
            document.addEventListener('mousemove', onMouseMove);
            
            document.addEventListener('touchstart', e => { 
                isDragging = true; 
                prevMouse = {x: e.touches[0].clientX, y: e.touches[0].clientY}; 
            }, {passive: false});
            document.addEventListener('touchend', () => isDragging = false);
            document.addEventListener('touchmove', onTouchMove, {passive: false});
        }

        function createPlayer() {
            playerMesh = new THREE.Group();

            // Materials
            const bodyMat = new THREE.MeshStandardMaterial({ color: COLORS.player, roughness: 0.3 });
            const faceMat = new THREE.MeshStandardMaterial({ color: COLORS.playerFace, roughness: 0.1 });
            const limbMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White socks/limbs

            // --- 1. HEAD (Big Boxy Head) ---
            const headGeo = new THREE.BoxGeometry(0.9, 0.7, 0.75); 
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.y = 1.55;
            head.castShadow = true;
            playerMesh.add(head);

            // Face (Visor/Eyes)
            const faceGeo = new THREE.BoxGeometry(0.7, 0.25, 0.1);
            const face = new THREE.Mesh(faceGeo, faceMat);
            face.position.set(0, 1.55, 0.38);
            playerMesh.add(face);
            
            // Antenna
            const antStem = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.4), new THREE.MeshStandardMaterial({color: 0x555555}));
            antStem.position.set(0, 2.0, 0);
            playerMesh.add(antStem);
            const antBulb = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshStandardMaterial({color: 0xffff00, emissive: 0xaa8800}));
            antBulb.position.set(0, 2.2, 0);
            playerMesh.add(antBulb);

            // --- 2. BODY ---
            const bodyGeo = new THREE.BoxGeometry(0.6, 0.7, 0.45);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.85;
            body.castShadow = true;
            playerMesh.add(body);

            // --- 3. LIMBS ---
            const limbGeo = new THREE.BoxGeometry(0.22, 0.6, 0.22);
            
            // Arms
            playerMesh.leftArm = new THREE.Mesh(limbGeo, bodyMat);
            playerMesh.leftArm.position.set(-0.45, 0.9, 0);
            playerMesh.leftArm.castShadow = true;
            playerMesh.add(playerMesh.leftArm);

            playerMesh.rightArm = new THREE.Mesh(limbGeo, bodyMat);
            playerMesh.rightArm.position.set(0.45, 0.9, 0);
            playerMesh.rightArm.castShadow = true;
            playerMesh.add(playerMesh.rightArm);

            // Legs
            playerMesh.leftLeg = new THREE.Mesh(limbGeo, limbMat);
            playerMesh.leftLeg.position.set(-0.18, 0.3, 0);
            playerMesh.leftLeg.castShadow = true;
            playerMesh.add(playerMesh.leftLeg);

            playerMesh.rightLeg = new THREE.Mesh(limbGeo, limbMat);
            playerMesh.rightLeg.position.set(0.18, 0.3, 0);
            playerMesh.rightLeg.castShadow = true;
            playerMesh.add(playerMesh.rightLeg);

            scene.add(playerMesh);
        }

        function createPlatform(x, y, z, w, h, d, color, type = 'static') {
            const geometry = new THREE.BoxGeometry(w, h, d);
            const material = new THREE.MeshStandardMaterial({ 
                color: color || COLORS.platformTop,
                flatShading: true 
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const platformData = {
                mesh: mesh,
                bounds: { x, y, z, w, h, d }, // Center based
                type: type,
                initialPos: {x, y, z},
                timeOffset: Math.random() * 100
            };

            platforms.push(platformData);
            if (type === 'moving_y' || type === 'moving_x' || type === 'rotate') {
                movingPlatforms.push(platformData);
            }
            return platformData;
        }

        function createCheckpoint(x, y, z, levelIndex) {
            const geo = new THREE.CylinderGeometry(2, 2, 0.5, 16);
            const mat = new THREE.MeshStandardMaterial({ 
                color: COLORS.checkpoint, 
                emissive: 0x222222,
                transparent: true, opacity: 0.8 
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            scene.add(mesh);

            // Flag pole
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4), new THREE.MeshStandardMaterial({color: 0x888888}));
            pole.position.set(0, 2, 0);
            mesh.add(pole);

            // Flag
            const flag = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 0.1), new THREE.MeshStandardMaterial({color: 0xff5555}));
            flag.position.set(0.8, 3.5, 0);
            mesh.add(flag);

            checkPoints.push({
                mesh: mesh,
                bounds: {x, y, z, w: 4, h: 1, d: 4},
                level: levelIndex,
                spawn: { x, y: y + 2, z }
            });
        }

        function generateLevels() {
            // --- Start Platform ---
            createPlatform(0, 0, 0, 10, 2, 10, 0x88cc88);
            
            let cx = 0, cy = 0, cz = 0;
            
            // --- Level 1 ---
            for(let i=0; i<5; i++) {
                cz -= 6;
                createPlatform(cx, cy, cz, 3, 1, 3, COLORS.platformTop);
            }
            cz -= 8;
            createPlatform(cx, cy, cz, 6, 1, 6, COLORS.platformBase);
            createCheckpoint(cx, cy + 0.5, cz, 2);
            
            // --- Level 2 ---
            for(let i=0; i<6; i++) {
                cz -= 5;
                cy += 1.5;
                createPlatform(cx, cy, cz, 3, 1, 3);
            }
            cz -= 6;
            createPlatform(cx, cy, cz, 6, 1, 6, COLORS.platformBase);
            createCheckpoint(cx, cy + 0.5, cz, 3);

            // --- Level 3 ---
            for(let i=0; i<4; i++) {
                cz -= 7;
                createPlatform(cx, cy, cz, 3, 0.5, 3, 0xffaaaa, 'moving_x');
            }
            cz -= 8;
            createPlatform(cx, cy, cz, 6, 1, 6, COLORS.platformBase);
            createCheckpoint(cx, cy + 0.5, cz, 4);

            // --- Level 4 ---
            for(let i=0; i<3; i++) {
                cz -= 8;
                createPlatform(cx, cy, cz, 0.8, 0.5, 6, 0xffffaa);
            }
            cz -= 8;
            createPlatform(cx, cy, cz, 6, 1, 6, COLORS.platformBase);
            createCheckpoint(cx, cy + 0.5, cz, 5);

            // --- Level 5 ---
            for(let i=0; i<6; i++) {
                cz -= 5;
                cx += (i % 2 === 0) ? 4 : -4;
                cy += 0.5;
                createPlatform(cx, cy, cz, 2.5, 0.5, 2.5, 0xaaffaa);
            }
            cz -= 6; cx = cx; 
            createPlatform(cx, cy, cz, 6, 1, 6, COLORS.platformBase);
            createCheckpoint(cx, cy + 0.5, cz, 6);

            // --- Level 6 ---
            for(let i=0; i<4; i++) {
                cz -= 6;
                createPlatform(cx, cy, cz, 3, 0.5, 3, 0xddaaff, 'moving_y');
            }
            cz -= 7; cy += 2; 
            createPlatform(cx, cy, cz, 6, 1, 6, COLORS.platformBase);
            createCheckpoint(cx, cy + 0.5, cz, 7);

            // --- Level 7 ---
            for(let i=0; i<5; i++) {
                cz -= 9; 
                cy -= 0.5;
                createPlatform(cx, cy, cz, 3, 1, 3);
            }
            cz -= 8;
            createPlatform(cx, cy, cz, 6, 1, 6, COLORS.platformBase);
            createCheckpoint(cx, cy + 0.5, cz, 8);

            // --- Level 8 ---
            for(let i=0; i<8; i++) {
                cz -= 4;
                cx += Math.sin(i) * 3;
                createPlatform(cx, cy, cz, 1.5, 0.5, 1.5, 0xffcccc);
            }
            cz -= 6; cx = Math.round(cx);
            createPlatform(cx, cy, cz, 6, 1, 6, COLORS.platformBase);
            createCheckpoint(cx, cy + 0.5, cz, 9);

            // --- Level 9 ---
            let angle = 0;
            let radius = 8;
            for(let i=0; i<15; i++) {
                angle += 0.6;
                cy += 1.2;
                let px = cx + Math.sin(angle) * radius;
                let pz = cz + Math.cos(angle) * radius;
                createPlatform(px, cy, pz, 3, 0.5, 3, 0xccffff);
            }
            
            // Top of tower
            let fx = cx + Math.sin(angle) * radius;
            let fz = cz + Math.cos(angle) * radius;
            
            // --- Level 10 ---
            createPlatform(fx, cy + 1, fz, 10, 1, 10, COLORS.finish);
            
            const trophyGeo = new THREE.TorusKnotGeometry(1, 0.3, 100, 16);
            const trophyMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
            const trophy = new THREE.Mesh(trophyGeo, trophyMat);
            trophy.position.set(fx, cy + 3, fz);
            scene.add(trophy);
            
            movingPlatforms.push({ mesh: trophy, type: 'trophy' });
        }

        function createWater() {
            const waterGeo = new THREE.PlaneGeometry(1000, 1000);
            waterGeo.rotateX(-Math.PI / 2);
            const waterMat = new THREE.MeshBasicMaterial({ color: COLORS.water, transparent: true, opacity: 0.6 });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.position.y = -20;
            scene.add(water);
        }

        // --- Input (UPDATED: Uses e.code for better Layout Support) ---
        function onKey(e, isDown) {
            const code = e.code;
            // W / ArrowUp
            if(code === 'KeyW' || code === 'ArrowUp') keys.w = isDown;
            // S / ArrowDown
            if(code === 'KeyS' || code === 'ArrowDown') keys.s = isDown;
            // A / ArrowLeft
            if(code === 'KeyA' || code === 'ArrowLeft') keys.a = isDown;
            // D / ArrowRight
            if(code === 'KeyD' || code === 'ArrowRight') keys.d = isDown;
            // Space
            if(code === 'Space') keys.space = isDown;
            // Shift
            if(code === 'ShiftLeft' || code === 'ShiftRight') keys.shift = isDown;
        }

        function onMouseMove(e) {
            if(!isDragging) return;
            const dx = e.clientX - prevMouse.x;
            const dy = e.clientY - prevMouse.y;
            cameraAngle.y -= dx * 0.005;
            cameraAngle.x -= dy * 0.005;
            cameraAngle.x = Math.max(-1.0, Math.min(1.0, cameraAngle.x));
            prevMouse = { x: e.clientX, y: e.clientY };
        }
        function onTouchMove(e) {
            e.preventDefault();
            if(!isDragging) return;
            const t = e.touches[0];
            const dx = t.clientX - prevMouse.x;
            const dy = t.clientY - prevMouse.y;
            cameraAngle.y -= dx * 0.008;
            cameraAngle.x -= dy * 0.008;
            cameraAngle.x = Math.max(-1.0, Math.min(1.0, cameraAngle.x));
            prevMouse = { x: t.clientX, y: t.clientY };
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Physics Engine (AABB) ---
        function checkCollision(px, py, pz) {
            const pw = 0.8;
            const ph = 1.0;

            for(let p of platforms) {
                const mx = p.mesh.position.x;
                const my = p.mesh.position.y;
                const mz = p.mesh.position.z;
                const mw = p.bounds.w;
                const mh = p.bounds.h;
                const md = p.bounds.d;

                // Horizontal
                if (px > mx - mw/2 - pw/2 && px < mx + mw/2 + pw/2 &&
                    pz > mz - md/2 - pw/2 && pz < mz + md/2 + pw/2) {
                    
                    // Vertical
                    if (py >= my + mh/2 - 0.1 && py <= my + mh/2 + 0.5 && playerState.vy <= 0) {
                        return { hit: true, y: my + mh/2, platform: p };
                    }
                }
            }
            return { hit: false };
        }
        
        function checkCheckpointCollisions(px, py, pz) {
            for(let cp of checkPoints) {
                const dx = px - cp.mesh.position.x;
                const dz = pz - cp.mesh.position.z;
                if(Math.sqrt(dx*dx + dz*dz) < 2 && Math.abs(py - cp.mesh.position.y) < 3) {
                    if(playerState.currentLevel < cp.level) {
                        playerState.currentLevel = cp.level;
                        playerState.spawnPoint = { ...cp.spawn };
                        showToast(`Stage ${cp.level}`);
                        cp.mesh.material.emissive.setHex(0x00ff00);
                        document.getElementById('level-display').innerText = `Stage: ${cp.level}/10`;
                    }
                }
            }
        }

        function showToast(msg) {
            const el = document.getElementById('message-text');
            const box = document.getElementById('message-overlay');
            el.innerText = msg;
            box.style.opacity = 1;
            box.style.transform = "translate(-50%, -50%) scale(1.1)";
            setTimeout(() => {
                box.style.opacity = 0;
                box.style.transform = "translate(-50%, -50%) scale(1)";
            }, 2000);
        }

        function updateMovingPlatforms(time) {
            movingPlatforms.forEach(p => {
                if(p.type === 'moving_x') {
                    p.mesh.position.x = p.initialPos.x + Math.sin(time * 2 + p.timeOffset) * 3;
                } else if (p.type === 'moving_y') {
                    p.mesh.position.y = p.initialPos.y + Math.sin(time * 1.5 + p.timeOffset) * 2;
                } else if (p.type === 'trophy') {
                    p.mesh.rotation.y += 0.02;
                    p.mesh.rotation.x = Math.sin(time) * 0.1;
                }
            });
        }

        function updatePlayerLogic() {
            // 1. Camera basis
            // Forward vector (เดินหน้าไปทาง Z บวก ตามมุมกล้อง)
            const forward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle.y);
            // Right vector (ทิศทางขวา)
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraAngle.y);

            // 2. Movement Input
            let moveX = 0, moveZ = 0;
            const currentSpeed = keys.shift ? RUN_SPEED : SPEED;
            
            // Logic:
            // W = เดินหน้า (ตามทิศ forward)
            // S = ถอยหลัง (ย้อนทิศ forward)
            // A = เดินซ้าย (ย้อนทิศ right -> แก้ไข: ปรับเครื่องหมายให้ถูกต้องตาม Feedback)
            // D = เดินขวา (ตามทิศ right -> แก้ไข: ปรับเครื่องหมายให้ถูกต้องตาม Feedback)
            
            if(keys.w) { moveX += forward.x; moveZ += forward.z; }
            if(keys.s) { moveX -= forward.x; moveZ -= forward.z; }
            
            // แก้ไขสลับด้าน A/D
            // ถ้าก่อนหน้านี้ A พาไปขวา แปลว่า -right คือขวา ดังนั้นเราต้องเปลี่ยนเครื่องหมาย
            // ลองสลับ Logic ตรงนี้เพื่อให้ตรงกับหน้าจอจริง
            if(keys.a) { moveX += right.x; moveZ += right.z; } // เปลี่ยนจาก - เป็น + (เพื่อให้ไปทางซ้าย ถ้า vector มันกลับด้าน)
            if(keys.d) { moveX -= right.x; moveZ -= right.z; } // เปลี่ยนจาก + เป็น - (เพื่อให้ไปทางขวา)

            // Normalize & Rotate Character
            if(moveX!==0 || moveZ!==0) {
                const len = Math.sqrt(moveX*moveX + moveZ*moveZ);
                moveX = (moveX/len) * currentSpeed;
                moveZ = (moveZ/len) * currentSpeed;
                
                const targetRot = Math.atan2(moveX, moveZ);
                
                let rotDiff = targetRot - playerMesh.rotation.y;
                while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                playerMesh.rotation.y += rotDiff * 0.2; 
                
                walkCycle += 0.3;
                playerMesh.leftLeg.rotation.x = Math.sin(walkCycle) * 0.8;
                playerMesh.rightLeg.rotation.x = Math.cos(walkCycle) * 0.8;
                playerMesh.leftArm.rotation.x = -Math.sin(walkCycle) * 0.6;
                playerMesh.rightArm.rotation.x = -Math.cos(walkCycle) * 0.6;
            } else {
                const breathe = Math.sin(Date.now() * 0.005) * 0.05;
                playerMesh.leftLeg.rotation.x = 0;
                playerMesh.rightLeg.rotation.x = 0;
                playerMesh.leftArm.rotation.x = 0;
                playerMesh.leftArm.rotation.z = 0.1 + breathe;
                playerMesh.rightArm.rotation.x = 0;
                playerMesh.rightArm.rotation.z = -0.1 - breathe;
            }

            // 3. Apply Horizontal Move
            playerState.x += moveX;
            playerState.z += moveZ;

            // 4. Apply Gravity & Jump
            playerState.vy -= GRAVITY;
            
            let nextY = playerState.y + playerState.vy;
            const groundCheck = checkCollision(playerState.x, playerState.y, playerState.z);
            
            if (groundCheck.hit && playerState.vy <= 0) {
                playerState.y = groundCheck.y;
                playerState.vy = 0;
                playerState.onGround = true;

                if(keys.space) {
                    playerState.vy = JUMP_FORCE;
                    playerState.onGround = false;
                }
            } else {
                playerState.y = nextY;
                playerState.onGround = false;
            }

            checkCheckpointCollisions(playerState.x, playerState.y, playerState.z);

            if (playerState.y < -10) {
                playerState.x = playerState.spawnPoint.x;
                playerState.y = playerState.spawnPoint.y;
                playerState.z = playerState.spawnPoint.z;
                playerState.vy = 0;
                showToast("OOF!");
            }

            playerMesh.position.set(playerState.x, playerState.y, playerState.z);
            
            // Camera Follow
            const camX = playerState.x - Math.sin(cameraAngle.y) * CAM_DISTANCE * Math.cos(cameraAngle.x);
            const camY = playerState.y + CAM_HEIGHT + Math.sin(cameraAngle.x) * CAM_DISTANCE;
            const camZ = playerState.z - Math.cos(cameraAngle.y) * CAM_DISTANCE * Math.cos(cameraAngle.x);
            
            camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.1);
            camera.lookAt(playerState.x, playerState.y + 1, playerState.z);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            updateMovingPlatforms(time);
            updatePlayerLogic();
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>